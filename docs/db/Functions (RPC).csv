schema_name,function_name,identity_args,return_type,language,volatility,security_definer,function_definition
auth,email,,text,sql,s,false,"CREATE OR REPLACE FUNCTION auth.email()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.email', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')
  )::text
$function$
"
auth,jwt,,jsonb,sql,s,false,"CREATE OR REPLACE FUNCTION auth.jwt()
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select 
    coalesce(
        nullif(current_setting('request.jwt.claim', true), ''),
        nullif(current_setting('request.jwt.claims', true), '')
    )::jsonb
$function$
"
auth,role,,text,sql,s,false,"CREATE OR REPLACE FUNCTION auth.role()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.role', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')
  )::text
$function$
"
auth,uid,,uuid,sql,s,false,"CREATE OR REPLACE FUNCTION auth.uid()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.sub', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')
  )::uuid
$function$
"
public,_set_updated_at,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION public._set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.updated_at = now();
  return new;
end;
$function$
"
public,_upsert_notification,"p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb",void,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public._upsert_notification(p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  -- Prevent self notifications
  if p_user_id is null or p_actor_id is null then
    return;
  end if;
  if p_user_id = p_actor_id then
    return;
  end if;

  insert into public.notifications (user_id, actor_id, type, entity_type, entity_id, payload, is_read, read_at, created_at)
  values (p_user_id, p_actor_id, p_type, p_entity_type, p_entity_id, p_payload, false, null, now())
  on conflict (user_id, type, actor_id, entity_id)
  do update set
    payload   = excluded.payload,
    is_read   = false,
    read_at   = null,
    created_at = now();
end;
$function$
"
public,actor_snapshot,p_actor_id uuid,jsonb,sql,s,false,"CREATE OR REPLACE FUNCTION public.actor_snapshot(p_actor_id uuid)
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select jsonb_build_object(
    'actor_id', p.id,
    'actor_username', p.username,
    'actor_display_name', coalesce(nullif(trim(p.display_name), ''), 'אנונימי'),
    'actor_avatar_url', p.avatar_url
  )
  from public.profiles p
  where p.id = p_actor_id
$function$
"
public,cleanup_notification_on_comment_unlike,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.cleanup_notification_on_comment_unlike()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  delete from public.notifications n
  where (n.payload->>'action') = 'comment_like'
    and (n.payload->>'comment_id') = old.comment_id::text
    and (n.payload->>'from_user_id') = old.user_id::text;

  return old;
end;
$function$
"
public,cleanup_notifications_on_comment_delete,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.cleanup_notifications_on_comment_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  -- מוחק כל notification שמצביע על comment_id הזה בתוך payload
  delete from public.notifications n
  where (n.payload->>'comment_id') = old.id::text
     or (n.entity_id is not null and n.entity_id::text = old.id::text);

  return old;
end;
$function$
"
public,enforce_max_3_reactions,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION public.enforce_max_3_reactions()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  cnt int;
begin
  select count(*) into cnt
  from public.post_reaction_votes
  where post_id = new.post_id and voter_id = new.voter_id;

  if cnt >= 3 then
    raise exception 'Max 3 reactions per post';
  end if;

  return new;
end;
$function$
"
public,get_my_conversations,,"TABLE(conversation_id uuid, other_username text, other_display_name text, other_avatar_url text, last_message_body text, last_message_at timestamp with time zone, unread_count integer)",sql,s,true,"CREATE OR REPLACE FUNCTION public.get_my_conversations()
 RETURNS TABLE(conversation_id uuid, other_username text, other_display_name text, other_avatar_url text, last_message_body text, last_message_at timestamp with time zone, unread_count integer)
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  select
    t.conversation_id,
    t.other_username,
    t.other_display_name,
    t.other_avatar_url,
    t.last_message_body,
    t.last_message_at,
    t.unread_count
  from public.inbox_threads t
  order by t.last_message_at desc nulls last;
$function$
"
public,get_profile_reaction_totals,p_profile_id uuid,"TABLE(reaction_key text, label_he text, total_votes integer, sort_order integer)",sql,s,false,"CREATE OR REPLACE FUNCTION public.get_profile_reaction_totals(p_profile_id uuid)
 RETURNS TABLE(reaction_key text, label_he text, total_votes integer, sort_order integer)
 LANGUAGE sql
 STABLE
AS $function$
  select
    r.key as reaction_key,
    r.label_he,
    coalesce(t.total_votes, 0)::int as total_votes,
    r.sort_order
  from public.reactions r
  left join public.profile_reaction_totals t
    on t.profile_id = p_profile_id
   and t.reaction_key = r.key
  where r.is_active = true
  order by r.sort_order asc;
$function$
"
public,handle_new_user,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_display_name text;
  v_username text;
begin
  v_display_name := coalesce(new.raw_user_meta_data->>'display_name', 'משתמש');

  -- use provided username if exists, else generate one
  v_username := nullif(new.raw_user_meta_data->>'username', '');
  if v_username is null then
    v_username := 'user_' || substr(replace(new.id::text, '-', ''), 1, 10);
  end if;

  insert into public.profiles (id, display_name, username, avatar_url)
  values (
    new.id,
    v_display_name,
    v_username,
    'https://api.dicebear.com/7.x/initials/svg?seed=' || v_display_name
  )
  on conflict (id) do nothing;

  return new;
end;
$function$
"
public,insert_notification,"p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb",void,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.insert_notification(p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  insert into public.notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload,
    is_read,
    created_at,
    read_at
  )
  values (
    p_user_id,
    p_actor_id,
    p_type,
    p_entity_type,
    p_entity_id,
    coalesce(p_payload, '{}'::jsonb),
    false,
    now(),
    null
  )
  on conflict on constraint notifications_unique_event
  do update set
    payload = excluded.payload,
    is_read = false,
    read_at = null,
    created_at = now();
end;
$function$
"
public,insert_notification_upsert,"p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb",void,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.insert_notification_upsert(p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  insert into public.notifications (
    user_id, actor_id, type, entity_type, entity_id, payload, is_read, created_at, read_at
  )
  values (
    p_user_id,
    p_actor_id,
    p_type,
    p_entity_type,
    p_entity_id,
    coalesce(p_payload, '{}'::jsonb),
    false,
    now(),
    null
  )
  on conflict on constraint notifications_unique_event
  do update set
    payload    = excluded.payload,
    is_read    = false,
    read_at    = null,
    created_at = now();
end;
$function$
"
public,limit_three_ratings_per_post,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION public.limit_three_ratings_per_post()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  cnt int;
begin
  select count(*) into cnt
  from public.post_votes
  where post_id = new.post_id and voter_id = new.voter_id;

  if cnt >= 3 then
    raise exception 'Max 3 ratings per post per user';
  end if;

  return new;
end;
$function$
"
public,mark_conversation_read,p_conversation_id uuid,void,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.mark_conversation_read(p_conversation_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  update public.messages
  set read_at = now()
  where conversation_id = p_conversation_id
    and sender_id <> auth.uid()
    and read_at is null;
end;
$function$
"
public,notify_comment_delete,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_comment_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  post_author uuid;
  remaining int;
begin
  select p.author_id
    into post_author
  from public.posts p
  where p.id = old.post_id;

  if post_author is null then
    return old;
  end if;

  -- if the same actor still has comments on this post -> keep notification
  select count(*) into remaining
  from public.comments c
  where c.post_id = old.post_id
    and c.author_id = old.author_id;

  if remaining = 0 then
    delete from public.notifications n
    where n.user_id   = post_author
      and n.actor_id  = old.author_id
      and n.type      = 'comment'
      and n.entity_type = 'post'
      and n.entity_id = old.post_id;
  end if;

  return old;
end;
$function$
"
public,notify_comment_insert,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_comment_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  post_owner uuid;
  post_slug text;
  post_title text;
begin
  -- מביאים את בעל הפוסט + נתוני פוסט בסיסיים
  select p.author_id, p.slug, p.title
    into post_owner, post_slug, post_title
  from public.posts p
  where p.id = new.post_id;

  -- אם לא מצאנו פוסט - אין מה לעשות
  if post_owner is null then
    return new;
  end if;

  -- לא מודיעים לעצמך
  if post_owner = new.author_id then
    return new;
  end if;

  -- התראה לבעל הפוסט על תגובה חדשה (גם אם זו reply, עדיין אפשר להשאיר – אם אתם רוצים רק top-level תגיד לי)
  insert into public.notifications (user_id, type, entity_type, entity_id, payload)
  values (
    post_owner,
    'comment',
    'comment',
    new.id,
    jsonb_build_object(
      'action', case when new.parent_comment_id is null then 'comment' else 'comment_reply' end,
      'post_id', new.post_id::text,
      'post_slug', coalesce(post_slug, ''),
      'post_title', coalesce(post_title, ''),
      'comment_id', new.id::text,
      'parent_comment_id', coalesce(new.parent_comment_id::text, null),
      'comment_text', new.content,
      'from_user_id', new.author_id::text
    )
  );

  return new;
end;
$function$
"
public,notify_comment_like,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_comment_like()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_comment_author uuid;
  v_post_id uuid;
  v_post_slug text;
  v_post_title text;
begin
  select c.author_id, c.post_id
    into v_comment_author, v_post_id
  from public.comments c
  where c.id = new.comment_id;

  if v_comment_author is null then
    return new;
  end if;

  if v_comment_author = new.user_id then
    return new;
  end if;

  select p.slug, p.title
    into v_post_slug, v_post_title
  from public.posts p
  where p.id = v_post_id;

  insert into public.notifications (
    user_id, actor_id, type, entity_type, entity_id, payload, is_read, created_at
  )
  values (
    v_comment_author,
    new.user_id,
    'comment',              -- ✅ type חוקי
    'comment',
    new.comment_id,
    jsonb_build_object(
      'action', 'comment_like',     -- ✅ ככה ה-UI מבדיל שזה לייק לתגובה
      'post_id', v_post_id,
      'post_slug', v_post_slug,
      'post_title', v_post_title,
      'comment_id', new.comment_id
    ),
    false,
    now()
  )
  on conflict on constraint notifications_unique_event do nothing;

  return new;
end;
$function$
"
public,notify_follow,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_follow()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  -- חשוב: מאפשר לפונקציה לעבוד גם כש-RLS דלוק על notifications
  perform set_config('row_security', 'off', true);

  -- לא שולחים התראה על follow לעצמי (אם איכשהו קרה)
  if new.follower_id = new.following_id then
    return new;
  end if;

  if tg_op = 'INSERT' then
    insert into public.notifications (user_id, type, actor_id, entity_id)
    values (new.following_id, 'follow', new.follower_id, null)
    on conflict on constraint notifications_unique_event do nothing;

    return new;
  end if;

  if tg_op = 'DELETE' then
    delete from public.notifications n
    where n.user_id = old.following_id
      and n.type = 'follow'
      and n.actor_id = old.follower_id
      and n.entity_id is null;

    return old;
  end if;

  return null;
end;
$function$
"
public,notify_follow_delete,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_follow_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  -- remove follow notification when unfollow
  delete from public.notifications n
  where n.user_id   = old.following_id
    and n.actor_id  = old.follower_id
    and n.type      = 'follow'
    and n.entity_id = old.following_id;

  return old;
end;
$function$
"
public,notify_follow_insert,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_follow_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  actor_username text;
  actor_display_name text;
begin
  select p.username,
         coalesce(nullif(trim(p.display_name), ''), p.username)
    into actor_username, actor_display_name
  from public.profiles p
  where p.id = new.follower_id;

  perform public._upsert_notification(
    new.following_id,
    new.follower_id,
    'follow',
    'profile',
    new.following_id,
    jsonb_build_object(
      'actor_username', actor_username,
      'actor_display_name', actor_display_name
    )
  );

  return new;
end;
$function$
"
public,notify_followers_new_post,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_followers_new_post()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  is_publish_event boolean;
begin
  if tg_op = 'INSERT' then
    is_publish_event := (new.status = 'published');
  elsif tg_op = 'UPDATE' then
    is_publish_event := (old.status is distinct from 'published' and new.status = 'published');
  else
    is_publish_event := false;
  end if;

  if not is_publish_event then
    return new;
  end if;

  insert into public.notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload,
    is_read,
    created_at
  )
  select
    uf.follower_id,
    new.author_id,
    'new_post',
    'post',
    new.id,
    jsonb_build_object(
      'post_id', new.id,
      'post_slug', new.slug,
      'post_title', new.title,
      'author_id', new.author_id
    ),
    false,
    now()
  from public.user_follows uf
  where uf.following_id = new.author_id
    and uf.follower_id <> new.author_id
  on conflict (user_id, type, entity_type, entity_id)
  where type = 'new_post' and entity_type = 'post'
  do nothing;

  return new;
end;
$function$
"
public,notify_message_insert,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION public.notify_message_insert()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  recipient uuid;
begin
  select cp.user_id into recipient
  from public.conversation_participants cp
  where cp.conversation_id = new.conversation_id
    and cp.user_id <> new.sender_id
  limit 1;

  if recipient is null then
    return new;
  end if;

  insert into public.notifications (user_id, type, actor_id, entity_id)
  values (recipient, 'message', new.sender_id, new.conversation_id);

  return new;
end;
$function$
"
public,notify_on_comment,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION public.notify_on_comment()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  post_author uuid;
BEGIN
  -- מי בעל הפוסט
  SELECT author_id
  INTO post_author
  FROM posts
  WHERE id = NEW.post_id;

  -- לא שולחים התראה לעצמך
  IF post_author = NEW.author_id THEN
    RETURN NEW;
  END IF;

  INSERT INTO notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload
  )
  VALUES (
    post_author,
    NEW.author_id,
    'comment',
    'post',
    NEW.post_id,
    jsonb_build_object(
      'comment_id', NEW.id
    )
  )
  ON CONFLICT DO NOTHING;

  RETURN NEW;
END;
$function$
"
public,notify_on_comment_insert,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_on_comment_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  post_author uuid;
  post_slug text;
  actor_u text;
  actor_dn text;
begin
  select p.author_id, p.slug
  into post_author, post_slug
  from public.posts p
  where p.id = new.post_id;

  if post_author is null then
    return new;
  end if;

  if post_author = new.author_id then
    return new;
  end if;

  select pr.username, coalesce(nullif(trim(pr.display_name), ''), pr.username)
  into actor_u, actor_dn
  from public.profiles pr
  where pr.id = new.author_id;

  perform public.upsert_notification(
    post_author,
    new.author_id,
    'comment',
    'post',
    new.post_id,
    jsonb_build_object(
      'post_id', new.post_id,
      'post_slug', post_slug,
      'comment_preview', left(new.content, 80),
      'actor_username', actor_u,
      'actor_display_name', actor_dn
    )
  );

  return new;
end;
$function$
"
public,notify_on_comment_insert_fn,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION public.notify_on_comment_insert_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  v_post_author uuid;
  v_parent_author uuid;
  v_post_slug text;
  v_post_title text;
begin
  -- בעל הפוסט + נתוני פוסט לניווט/טקסט
  select p.author_id, p.slug, p.title
    into v_post_author, v_post_slug, v_post_title
  from public.posts p
  where p.id = new.post_id;

  if v_post_author is null then
    return new;
  end if;

  -- 1) התראה לבעל הפוסט (גם אם זו תגובת-משנה)
  if v_post_author <> new.author_id then
    perform public.insert_notification(
      v_post_author,
      new.author_id,
      'comment',
      'comment',
      new.id,
      jsonb_build_object(
        'post_id', new.post_id,
        'post_slug', v_post_slug,
        'post_title', v_post_title,
        'comment_id', new.id
      )
    );
  end if;

  -- 2) אם זו תגובה לתגובה: התראה לבעל התגובה ההורה (B)
  if new.parent_comment_id is not null then
    select c.author_id
      into v_parent_author
    from public.comments c
    where c.id = new.parent_comment_id;

    if v_parent_author is not null
       and v_parent_author <> new.author_id
       and v_parent_author <> v_post_author then
      perform public.insert_notification(
        v_parent_author,
        new.author_id,
        'comment',
        'comment',
        new.id,
        jsonb_build_object(
          'post_id', new.post_id,
          'post_slug', v_post_slug,
          'post_title', v_post_title,
          'comment_id', new.id,
          'parent_comment_id', new.parent_comment_id
        )
      );
    end if;
  end if;

  return new;
end;
$function$
"
public,notify_on_comment_like,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_on_comment_like()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_comment_owner uuid;
  v_post_id uuid;
  v_post_title text;
  v_liker_name text;
  v_type text;
begin
  -- Fetch comment owner + post_id from comments table (NOT post_comments)
  select c.author_id, c.post_id
    into v_comment_owner, v_post_id
  from public.comments c
  where c.id = new.comment_id;

  if v_comment_owner is null then
    return new;
  end if;

  -- Don't notify on self-like
  if v_comment_owner = new.user_id then
    return new;
  end if;

  -- pick a notifications.type that passes the CHECK constraint:
  -- try to reuse an existing value already stored in notifications
  select n.type into v_type
  from public.notifications n
  where n.type is not null
  limit 1;

  if v_type is null then
    v_type := 'reaction';
  end if;

  -- liker display name
  select coalesce(p.display_name, p.username, 'משתמש/ת')
    into v_liker_name
  from public.profiles p
  where p.id = new.user_id;

  -- post title (optional)
  select coalesce(p2.title, 'ללא כותרת')
    into v_post_title
  from public.posts p2
  where p2.id = v_post_id;

  insert into public.notifications (user_id, type, payload)
  values (
    v_comment_owner,
    v_type,
    jsonb_build_object(
      'action', 'comment_like',
      'from_user_id', new.user_id,
      'from_user_name', v_liker_name,
      'post_id', v_post_id,
      'post_title', v_post_title,
      'comment_id', new.comment_id
    )
  );

  return new;
end;
$function$
"
public,notify_on_comment_reply,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_on_comment_reply()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  parent_owner uuid;
begin
  -- רק אם זו תגובת reply
  if new.parent_comment_id is null then
    return new;
  end if;

  -- בעל התגובה שאליה עונים
  select c.author_id into parent_owner
  from public.comments c
  where c.id = new.parent_comment_id;

  -- אין parent / או reply לעצמך -> לא מודיעים
  if parent_owner is null or parent_owner = new.author_id then
    return new;
  end if;

  -- מוסיפים notification לבעל התגובה המקורית
  insert into public.notifications (user_id, type, payload, entity_id)
  values (
    parent_owner,
    'comment',
    jsonb_build_object(
      'action', 'comment_reply',
      'comment_id', new.id::text,                  -- ה-reply החדש (בשביל highlight)
      'parent_comment_id', new.parent_comment_id::text,
      'post_id', new.post_id::text,
      'from_user_id', new.author_id::text
    ),
    new.id
  );

  return new;
end;
$function$
"
public,notify_on_follow,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_on_follow()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_payload jsonb;
begin
  -- לא שולחים התראה אם משתמש עוקב אחרי עצמו (ליתר ביטחון)
  if new.follower_id = new.following_id then
    return new;
  end if;

  v_payload :=
    jsonb_build_object(
      'following_id', new.following_id,
      'follower_id', new.follower_id
    )
    || coalesce(public.actor_snapshot(new.follower_id), '{}'::jsonb);

  perform public.insert_notification_upsert(
    new.following_id,          -- מקבל ההתראה
    new.follower_id,           -- מי עשה את הפעולה
    'follow',
    'profile',
    new.follower_id,           -- entity_id: מי שעוקב (או אפשר following_id — לא קריטי כל עוד עקבי)
    v_payload
  );

  return new;
end;
$function$
"
public,notify_on_follow_insert,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_on_follow_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  actor_display text;
  actor_username text;
begin
  -- לא שולחים התראה על self-follow (ליתר ביטחון)
  if new.follower_id = new.following_id then
    return new;
  end if;

  select
    coalesce(nullif(trim(p.display_name), ''), p.username, 'מישהו'),
    p.username
  into actor_display, actor_username
  from public.profiles p
  where p.id = new.follower_id;

  insert into public.notifications (user_id, actor_id, type, entity_type, entity_id, payload, is_read)
  values (
    new.following_id,
    new.follower_id,
    'follow',
    'profile',
    new.follower_id,
    jsonb_build_object(
      'actor_display_name', actor_display,
      'actor_username', actor_username
    ),
    false
  )
  on conflict (user_id, type, actor_id, entity_id) do update
    set created_at = now(),
        is_read = false,
        payload = excluded.payload;

  return new;
end $function$
"
public,notify_on_reaction,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION public.notify_on_reaction()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  post_author uuid;
BEGIN
  SELECT author_id
  INTO post_author
  FROM posts
  WHERE id = NEW.post_id;

  IF post_author = NEW.voter_id THEN
    RETURN NEW;
  END IF;

  INSERT INTO notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload
  )
  VALUES (
    post_author,
    NEW.voter_id,
    'reaction',
    'post',
    NEW.post_id,
    jsonb_build_object(
      'reaction', NEW.reaction_key
    )
  )
  ON CONFLICT DO NOTHING;

  RETURN NEW;
END;
$function$
"
public,notify_on_reaction_insert,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_on_reaction_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_post_author uuid;
  v_post_slug text;
  v_actor_username text;
  v_actor_display text;
BEGIN
  -- מי בעל הפוסט?
  SELECT author_id, slug
    INTO v_post_author, v_post_slug
  FROM public.posts
  WHERE id = NEW.post_id;

  IF v_post_author IS NULL THEN
    RETURN NEW;
  END IF;

  -- לא שולחים התראה על ריאקשן לעצמך
  IF v_post_author = NEW.voter_id THEN
    RETURN NEW;
  END IF;

  -- פרטי השחקן (מי שעשה)
  SELECT username, COALESCE(NULLIF(trim(display_name), ''), username)
    INTO v_actor_username, v_actor_display
  FROM public.profiles
  WHERE id = NEW.voter_id;

  INSERT INTO public.notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload,
    is_read
  )
  VALUES (
    v_post_author,
    NEW.voter_id,
    'reaction',
    'post',
    NEW.post_id,
    jsonb_build_object(
      'post_id', NEW.post_id,
      'post_slug', v_post_slug,
      'reaction_key', NEW.reaction_key,
      'actor_username', v_actor_username,
      'actor_display_name', v_actor_display
    ),
    false
  )
  ON CONFLICT (user_id, type, actor_id, entity_id) DO UPDATE
    SET created_at = now(),
        is_read = false,
        read_at = null,
        payload = EXCLUDED.payload;

  RETURN NEW;
END;
$function$
"
public,notify_on_reaction_insert_fn,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION public.notify_on_reaction_insert_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  v_post_author uuid;
begin
  select p.author_id into v_post_author
  from public.posts p
  where p.id = new.post_id;

  if v_post_author is null then
    return new;
  end if;

  -- לא שולחים התראה לעצמך
  if v_post_author = new.voter_id then
    return new;
  end if;

  -- בריאקשן: כן הגיוני ""אחד לכל פוסט לכל משתמש"" => entity_id = post_id
  perform public.insert_notification(
    v_post_author,
    new.voter_id,
    'reaction',
    'post',
    new.post_id,
    jsonb_build_object(
      'post_id', new.post_id,
      'reaction_key', new.reaction_key
    )
  );

  return new;
end;
$function$
"
public,notify_on_reaction_update,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_on_reaction_update()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_post_author uuid;
  v_post_slug text;
  v_payload jsonb;
begin
  -- אם לא באמת השתנה הריאקשן - אין מה לעשות
  if new.reaction_key is not distinct from old.reaction_key then
    return new;
  end if;

  select p.author_id, p.slug
    into v_post_author, v_post_slug
  from public.posts p
  where p.id = new.post_id;

  if v_post_author is null then
    return new;
  end if;

  if new.voter_id = v_post_author then
    return new;
  end if;

  v_payload :=
    jsonb_build_object(
      'post_id', new.post_id,
      'post_slug', v_post_slug,
      'reaction_key', new.reaction_key
    )
    || coalesce(public.actor_snapshot(new.voter_id), '{}'::jsonb);

  perform public.insert_notification_upsert(
    v_post_author,
    new.voter_id,
    'reaction',
    'post',
    new.post_id,
    v_payload
  );

  return new;
end;
$function$
"
public,notify_post_reaction,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_post_reaction()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  row_json jsonb;
  actor uuid;
  post_id uuid;
  post_author uuid;
begin
  perform set_config('row_security', 'off', true);

  if tg_op = 'DELETE' then
    row_json := to_jsonb(old);
  else
    row_json := to_jsonb(new);
  end if;

  actor :=
    coalesce(
      nullif(row_json->>'user_id','')::uuid,
      nullif(row_json->>'profile_id','')::uuid,
      nullif(row_json->>'author_id','')::uuid,
      nullif(row_json->>'reactor_id','')::uuid
    );

  post_id :=
    coalesce(
      nullif(row_json->>'post_id','')::uuid,
      nullif(row_json->>'entity_id','')::uuid
    );

  if actor is null or post_id is null then
    if tg_op = 'DELETE' then return old; else return new; end if;
  end if;

  select p.author_id into post_author
  from public.posts p
  where p.id = post_id;

  if post_author is null then
    if tg_op = 'DELETE' then return old; else return new; end if;
  end if;

  if post_author = actor then
    if tg_op = 'DELETE' then return old; else return new; end if;
  end if;

  if tg_op = 'INSERT' or tg_op = 'UPDATE' then
    insert into public.notifications (user_id, type, actor_id, entity_id)
    values (post_author, 'reaction', actor, post_id)
    on conflict on constraint notifications_unique_event do nothing;
  end if;

  if tg_op = 'DELETE' then
    delete from public.notifications n
    where n.user_id = post_author
      and n.type = 'reaction'
      and n.actor_id = actor
      and n.entity_id = post_id;
  end if;

  if tg_op = 'DELETE' then return old; else return new; end if;
end;
$function$
"
public,notify_reaction_delete,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_reaction_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  post_author uuid;
  remaining int;
begin
  select p.author_id
    into post_author
  from public.posts p
  where p.id = old.post_id;

  if post_author is null then
    return old;
  end if;

  -- if the same actor still has reactions on this post -> keep notification
  select count(*) into remaining
  from public.post_reaction_votes v
  where v.post_id = old.post_id
    and v.voter_id = old.voter_id;

  if remaining = 0 then
    delete from public.notifications n
    where n.user_id   = post_author
      and n.actor_id  = old.voter_id
      and n.type      = 'reaction'
      and n.entity_type = 'post'
      and n.entity_id = old.post_id;
  end if;

  return old;
end;
$function$
"
public,notify_reaction_insert,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.notify_reaction_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  post_author uuid;
  post_title text;
  post_slug text;
  actor_username text;
  actor_display_name text;
begin
  select p.author_id, p.title, p.slug
    into post_author, post_title, post_slug
  from public.posts p
  where p.id = new.post_id;

  if post_author is null then
    return new;
  end if;

  select pr.username,
         coalesce(nullif(trim(pr.display_name), ''), pr.username)
    into actor_username, actor_display_name
  from public.profiles pr
  where pr.id = new.voter_id;

  perform public._upsert_notification(
    post_author,
    new.voter_id,
    'reaction',
    'post',
    new.post_id,
    jsonb_build_object(
      'actor_username', actor_username,
      'actor_display_name', actor_display_name,
      'post_id', new.post_id,
      'post_slug', post_slug,
      'post_title', post_title,
      'reaction_key', new.reaction_key
    )
  );

  return new;
end;
$function$
"
public,pendemic_medals_reset4,v_votes integer,"TABLE(gold integer, silver integer, bronze integer)",sql,s,false,"CREATE OR REPLACE FUNCTION public.pendemic_medals_reset4(v_votes integer)
 RETURNS TABLE(gold integer, silver integer, bronze integer)
 LANGUAGE sql
 STABLE
AS $function$
  with vv as (
    select greatest(coalesce(v_votes,0),0)::int as votes
  ),
  bt as (
    select floor(votes/4.0)::int as b_total from vv
  ),
  st as (
    select b_total, floor(b_total/4.0)::int as s_total from bt
  ),
  gt as (
    select b_total, s_total, floor(s_total/4.0)::int as g_total from st
  )
  select
    greatest(g_total,0) as gold,
    greatest(s_total - (g_total * 4),0) as silver,
    greatest(b_total - (s_total * 4),0) as bronze
  from gt;
$function$
"
public,pendemic_medals_reset4_post_display,v_votes integer,"TABLE(gold integer, silver integer, bronze integer)",sql,s,false,"CREATE OR REPLACE FUNCTION public.pendemic_medals_reset4_post_display(v_votes integer)
 RETURNS TABLE(gold integer, silver integer, bronze integer)
 LANGUAGE sql
 STABLE
AS $function$
  with m as (
    select * from public.pendemic_medals_reset4(v_votes)
  )
  select
    least(m.gold, 6) as gold,
    m.silver as silver,
    m.bronze as bronze
  from m;
$function$
"
public,pendemic_month_bounds,ref_ts timestamp with time zone,"TABLE(start_ts timestamp with time zone, end_ts timestamp with time zone)",plpgsql,s,false,"CREATE OR REPLACE FUNCTION public.pendemic_month_bounds(ref_ts timestamp with time zone DEFAULT now())
 RETURNS TABLE(start_ts timestamp with time zone, end_ts timestamp with time zone)
 LANGUAGE plpgsql
 STABLE
AS $function$
declare
  tz text := 'Asia/Jerusalem';
  local_ts timestamp := (ref_ts at time zone tz);
  month_start_local timestamp := date_trunc('month', local_ts);
  month_end_local timestamp := (date_trunc('month', local_ts) + interval '1 month');
begin
  start_ts := month_start_local at time zone tz;
  end_ts := month_end_local at time zone tz;
  return next;
end;
$function$
"
public,pendemic_ranked_posts_monthly,"ref_ts timestamp with time zone, channel_slugs text[], limit_count integer","TABLE(post_id uuid, reactions_total integer, comments_total integer, reactions_by_key jsonb, gold integer, silver integer, bronze integer, window_start timestamp with time zone, window_end timestamp with time zone)",sql,s,false,"CREATE OR REPLACE FUNCTION public.pendemic_ranked_posts_monthly(ref_ts timestamp with time zone DEFAULT now(), channel_slugs text[] DEFAULT NULL::text[], limit_count integer DEFAULT 50)
 RETURNS TABLE(post_id uuid, reactions_total integer, comments_total integer, reactions_by_key jsonb, gold integer, silver integer, bronze integer, window_start timestamp with time zone, window_end timestamp with time zone)
 LANGUAGE sql
 STABLE
AS $function$
  with bounds as (
    select b.ws as window_start, b.we as window_end
    from public.pendemic_month_bounds(ref_ts) as b(ws, we)
  ),
  filtered_posts as (
    select p.id as pid
    from public.posts p
    left join public.channels c on c.id = p.channel_id
    where p.deleted_at is null
      and p.status = 'published'
      and (channel_slugs is null or c.slug = any(channel_slugs))
  ),
  votes_by_key as (
    select v.post_id as pid, v.reaction_key, count(*)::int as cnt
    from public.post_reaction_votes v
    cross join bounds b
    where v.created_at >= b.window_start
      and v.created_at <  b.window_end
    group by v.post_id, v.reaction_key
  ),
  votes as (
    select
      vbk.pid,
      sum(vbk.cnt)::int as reactions_total,
      jsonb_object_agg(vbk.reaction_key, vbk.cnt) as reactions_by_key
    from votes_by_key vbk
    group by vbk.pid
  ),
  comments as (
    select c.post_id as pid, count(*)::int as comments_total
    from public.comments c
    cross join bounds b
    where c.created_at >= b.window_start
      and c.created_at <  b.window_end
    group by c.post_id
  )
  select
    fp.pid as post_id,
    coalesce(v.reactions_total, 0) as reactions_total,
    coalesce(cm.comments_total, 0) as comments_total,
    coalesce(v.reactions_by_key, '{}'::jsonb) as reactions_by_key,
    (public.pendemic_medals_reset4(coalesce(v.reactions_total,0))).gold as gold,
    (public.pendemic_medals_reset4(coalesce(v.reactions_total,0))).silver as silver,
    (public.pendemic_medals_reset4(coalesce(v.reactions_total,0))).bronze as bronze,
    b.window_start,
    b.window_end
  from filtered_posts fp
  cross join bounds b
  left join votes v on v.pid = fp.pid
  left join comments cm on cm.pid = fp.pid
  order by coalesce(v.reactions_total,0) desc,
           coalesce(cm.comments_total,0) desc
  limit greatest(limit_count, 1);
$function$
"
public,pendemic_ranked_posts_weekly,"ref_ts timestamp with time zone, channel_slugs text[], limit_count integer","TABLE(post_id uuid, reactions_total integer, comments_total integer, reactions_by_key jsonb, gold integer, silver integer, bronze integer, window_start timestamp with time zone, window_end timestamp with time zone)",sql,s,false,"CREATE OR REPLACE FUNCTION public.pendemic_ranked_posts_weekly(ref_ts timestamp with time zone DEFAULT now(), channel_slugs text[] DEFAULT NULL::text[], limit_count integer DEFAULT 50)
 RETURNS TABLE(post_id uuid, reactions_total integer, comments_total integer, reactions_by_key jsonb, gold integer, silver integer, bronze integer, window_start timestamp with time zone, window_end timestamp with time zone)
 LANGUAGE sql
 STABLE
AS $function$
  with bounds as (
    select b.ws as window_start, b.we as window_end
    from public.pendemic_week_bounds(ref_ts) as b(ws, we)
  ),
  filtered_posts as (
    select p.id as pid
    from public.posts p
    left join public.channels c on c.id = p.channel_id
    where p.deleted_at is null
      and p.status = 'published'
      and (channel_slugs is null or c.slug = any(channel_slugs))
  ),
  votes_by_key as (
    select v.post_id as pid, v.reaction_key, count(*)::int as cnt
    from public.post_reaction_votes v
    cross join bounds b
    where v.created_at >= b.window_start
      and v.created_at <  b.window_end
    group by v.post_id, v.reaction_key
  ),
  votes as (
    select
      vbk.pid,
      sum(vbk.cnt)::int as reactions_total,
      jsonb_object_agg(vbk.reaction_key, vbk.cnt) as reactions_by_key
    from votes_by_key vbk
    group by vbk.pid
  ),
  comments as (
    select c.post_id as pid, count(*)::int as comments_total
    from public.comments c
    cross join bounds b
    where c.created_at >= b.window_start
      and c.created_at <  b.window_end
    group by c.post_id
  )
  select
    fp.pid as post_id,
    coalesce(v.reactions_total, 0) as reactions_total,
    coalesce(cm.comments_total, 0) as comments_total,
    coalesce(v.reactions_by_key, '{}'::jsonb) as reactions_by_key,
    (public.pendemic_medals_reset4(coalesce(v.reactions_total,0))).gold as gold,
    (public.pendemic_medals_reset4(coalesce(v.reactions_total,0))).silver as silver,
    (public.pendemic_medals_reset4(coalesce(v.reactions_total,0))).bronze as bronze,
    b.window_start,
    b.window_end
  from filtered_posts fp
  cross join bounds b
  left join votes v on v.pid = fp.pid
  left join comments cm on cm.pid = fp.pid
  order by coalesce(v.reactions_total,0) desc,
           coalesce(cm.comments_total,0) desc
  limit greatest(limit_count, 1);
$function$
"
public,pendemic_week_bounds,ref_ts timestamp with time zone,"TABLE(start_ts timestamp with time zone, end_ts timestamp with time zone)",plpgsql,s,false,"CREATE OR REPLACE FUNCTION public.pendemic_week_bounds(ref_ts timestamp with time zone DEFAULT now())
 RETURNS TABLE(start_ts timestamp with time zone, end_ts timestamp with time zone)
 LANGUAGE plpgsql
 STABLE
AS $function$
declare
  tz text := 'Asia/Jerusalem';
  local_ts timestamp := (ref_ts at time zone tz);
  local_midnight timestamp := date_trunc('day', local_ts);
  dow int := extract(dow from local_ts); -- sunday=0
  week_start_local timestamp := local_midnight - make_interval(days => dow);
  week_end_local timestamp := week_start_local + interval '7 days';
begin
  start_ts := week_start_local at time zone tz;
  end_ts := week_end_local at time zone tz;
  return next;
end;
$function$
"
public,prevent_self_like_comment,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.prevent_self_like_comment()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_comment_owner uuid;
begin
  select user_id into v_comment_owner
  from public.post_comments
  where id = new.comment_id;

  if v_comment_owner is null then
    return new;
  end if;

  if v_comment_owner = new.user_id then
    raise exception 'cannot_like_own_comment';
  end if;

  return new;
end;
$function$
"
public,prevent_self_vote,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION public.prevent_self_vote()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  author uuid;
begin
  select author_id into author from public.posts where id = new.post_id;

  if author = new.voter_id then
    raise exception 'Cannot vote on your own post';
  end if;

  return new;
end;
$function$
"
public,purge_post,p_post_id uuid,void,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.purge_post(p_post_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_author uuid;
begin
  select author_id into v_author
  from public.posts
  where id = p_post_id;

  if v_author is null then
    raise exception 'post not found';
  end if;

  if v_author <> auth.uid() then
    raise exception 'not allowed';
  end if;

  -- delete children first (avoid FK issues)
  delete from public.post_tags where post_id = p_post_id;
  delete from public.comments where post_id = p_post_id;
  delete from public.post_reaction_votes where post_id = p_post_id;
  delete from public.post_votes where post_id = p_post_id;
  delete from public.moderation_actions where post_id = p_post_id;

  -- notifications uses entity_type/entity_id
  delete from public.notifications
  where entity_type = 'post' and entity_id = p_post_id;

  delete from public.posts where id = p_post_id;
end;
$function$
"
public,purge_soft_deleted_posts,,void,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.purge_soft_deleted_posts()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  cutoff timestamptz := now() - interval '14 days';
begin
  delete from public.notifications
  where entity_type = 'post'
    and entity_id in (
      select id from public.posts
      where deleted_at is not null and deleted_at < cutoff
    );

  delete from public.post_reaction_votes
  where post_id in (
    select id from public.posts
    where deleted_at is not null and deleted_at < cutoff
  );

  delete from public.post_tags
  where post_id in (
    select id from public.posts
    where deleted_at is not null and deleted_at < cutoff
  );

  delete from public.comments
  where post_id in (
    select id from public.posts
    where deleted_at is not null and deleted_at < cutoff
  );

  delete from public.moderation_actions
  where post_id in (
    select id from public.posts
    where deleted_at is not null and deleted_at < cutoff
  );

  delete from public.posts
  where deleted_at is not null and deleted_at < cutoff;
end;
$function$
"
public,search_posts_v1,"p_query text, p_channel_id smallint, p_tag_id integer, p_sort text, p_limit integer, p_offset integer","TABLE(id uuid, author_id uuid, title text, slug text, excerpt text, status text, published_at timestamp with time zone, created_at timestamp with time zone, updated_at timestamp with time zone, channel_id smallint, subcategory_tag_id integer, cover_image_url text, is_anonymous boolean, comments_count bigint, reactions_count bigint, author_username text, author_display_name text, author_avatar_url text)",sql,s,false,"CREATE OR REPLACE FUNCTION public.search_posts_v1(p_query text DEFAULT NULL::text, p_channel_id smallint DEFAULT NULL::smallint, p_tag_id integer DEFAULT NULL::integer, p_sort text DEFAULT 'new'::text, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0)
 RETURNS TABLE(id uuid, author_id uuid, title text, slug text, excerpt text, status text, published_at timestamp with time zone, created_at timestamp with time zone, updated_at timestamp with time zone, channel_id smallint, subcategory_tag_id integer, cover_image_url text, is_anonymous boolean, comments_count bigint, reactions_count bigint, author_username text, author_display_name text, author_avatar_url text)
 LANGUAGE sql
 STABLE
AS $function$
  select
    pwc.id,
    pwc.author_id,
    pwc.title,
    pwc.slug,
    pwc.excerpt,
    pwc.status,
    pwc.published_at,
    pwc.created_at,
    pwc.updated_at,
    pwc.channel_id,
    pwc.subcategory_tag_id,
    pwc.cover_image_url,
    pwc.is_anonymous,
    pwc.comments_count,
    pwc.reactions_count,
    pr.username as author_username,
    pr.display_name as author_display_name,
    pr.avatar_url as author_avatar_url
  from public.posts_with_counts pwc
  join public.profiles pr on pr.id = pwc.author_id
  where
    -- keep published only (aligns with typical public feed expectations)
    pwc.status = 'published'
    and pwc.published_at is not null
    and pwc.published_at <= now()
    and (p_channel_id is null or pwc.channel_id = p_channel_id)
    and (
      p_tag_id is null
      or pwc.subcategory_tag_id = p_tag_id
      or exists (
        select 1
        from public.post_tags pt
        where pt.post_id = pwc.id
          and pt.tag_id = p_tag_id
      )
    )
    and (
      p_query is null
      or pwc.title ilike ('%' || p_query || '%')
      or (pwc.excerpt is not null and pwc.excerpt ilike ('%' || p_query || '%'))
    )
  order by
    case when p_sort = 'comments' then pwc.comments_count end desc nulls last,
    case when p_sort = 'reactions' then pwc.reactions_count end desc nulls last,
    -- default / tie-breaker
    coalesce(pwc.published_at, pwc.created_at) desc
  limit greatest(1, least(p_limit, 50))
  offset greatest(p_offset, 0);
$function$
"
public,send_message,"p_conversation_id uuid, p_body text",uuid,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.send_message(p_conversation_id uuid, p_body text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  me uuid;
  mid uuid;
begin
  me := auth.uid();
  if me is null then
    raise exception 'not authenticated';
  end if;

  if p_conversation_id is null then
    raise exception 'conversation_id is null';
  end if;

  if p_body is null or length(trim(p_body)) = 0 then
    raise exception 'empty body';
  end if;

  if not exists (
    select 1
    from public.conversation_members m
    where m.conversation_id = p_conversation_id
      and m.user_id = me
  ) then
    raise exception 'not a member of this conversation';
  end if;

  insert into public.messages (conversation_id, sender_id, body)
  values (p_conversation_id, me, trim(p_body))
  returning id into mid;

  return mid;
end;
$function$
"
public,set_message_sender,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION public.set_message_sender()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  if new.sender_id is null then
    new.sender_id := auth.uid();
  end if;

  return new;
end;
$function$
"
public,set_updated_at,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION public.set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.updated_at = now();
  return new;
end;
$function$
"
public,start_conversation,other_user_id uuid,uuid,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.start_conversation(other_user_id uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  me uuid := auth.uid();
  conv_id uuid;
begin
  if me is null then
    raise exception 'Not authenticated';
  end if;

  if other_user_id is null or other_user_id = me then
    raise exception 'Invalid user';
  end if;

  -- find existing 1:1 conversation that has exactly these two members
  select m1.conversation_id into conv_id
  from public.conversation_members m1
  join public.conversation_members m2
    on m2.conversation_id = m1.conversation_id
  where m1.user_id = me
    and m2.user_id = other_user_id
  group by m1.conversation_id
  having count(*) = 1; -- m1 row grouping; ensures pair exists (we’ll validate size next)

  if conv_id is not null then
    -- ensure it's only 2 members (true 1:1)
    if (select count(*) from public.conversation_members where conversation_id = conv_id) = 2 then
      return conv_id;
    end if;
  end if;

  -- create new conversation
  insert into public.conversations default values returning id into conv_id;

  insert into public.conversation_members (conversation_id, user_id, last_read_at)
  values
    (conv_id, me, now()),
    (conv_id, other_user_id, null);

  return conv_id;
end;
$function$
"
public,trg_notify_follow_delete,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.trg_notify_follow_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  perform set_config('row_security', 'off', true);

  delete from public.notifications n
  where n.user_id = old.following_id
    and n.type = 'follow'
    and n.actor_id = old.follower_id
    and n.entity_id = old.follower_id;

  return old;
end;
$function$
"
public,trg_notify_follow_delete_fn,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.trg_notify_follow_delete_fn()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  actor_username text;
  actor_display text;
begin
  if old.follower_id = old.following_id then
    return old;
  end if;

  select p.username,
         coalesce(nullif(trim(p.display_name), ''), p.username, 'מישהו')
    into actor_username, actor_display
  from public.profiles p
  where p.id = old.follower_id;

  insert into public.notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload,
    is_read
  )
  values (
    old.following_id,
    old.follower_id,
    'unfollow',
    'profile',
    old.follower_id,
    jsonb_build_object(
      'actor_username', actor_username,
      'actor_display_name', actor_display
    ),
    false
  )
  on conflict (user_id, type, actor_id, entity_id) do nothing;

  return old;
end;
$function$
"
public,trg_notify_follow_insert,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.trg_notify_follow_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  actor_name text;
  actor_username text;
begin
  -- לא שולחים לעצמך
  if new.follower_id = new.following_id then
    return new;
  end if;

  -- מכבים RLS בתוך ההקשר הזה בלבד (כדי שהטריגר תמיד יוכל להכניס notifications)
  perform set_config('row_security', 'off', true);

  select
    coalesce(nullif(trim(p.display_name), ''), p.username),
    p.username
  into actor_name, actor_username
  from public.profiles p
  where p.id = new.follower_id;

  insert into public.notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload,
    is_read
  )
  values (
    new.following_id,
    new.follower_id,
    'follow',
    'profile',
    new.follower_id, -- חשוב: זה מונע כפילויות מאותו עוקב בגלל ה-unique שלך
    jsonb_build_object(
      'actor_display_name', actor_name,
      'actor_username', actor_username
    ),
    false
  )
  on conflict on constraint notifications_unique_event
  do nothing;

  return new;
end;
$function$
"
public,trg_notify_follow_insert_fn,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.trg_notify_follow_insert_fn()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  actor_username text;
  actor_display text;
begin
  -- לא שולחים התראה לעצמך
  if new.follower_id = new.following_id then
    return new;
  end if;

  select p.username,
         coalesce(nullif(trim(p.display_name), ''), p.username, 'מישהו')
    into actor_username, actor_display
  from public.profiles p
  where p.id = new.follower_id;

  insert into public.notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload,
    is_read
  )
  values (
    new.following_id,              -- מי שמקבל
    new.follower_id,               -- מי שעשה
    'follow',
    'profile',
    new.follower_id,               -- entity_id = השחקן (או אפשר following_id, אבל אז זה משפיע על unique)
    jsonb_build_object(
      'actor_username', actor_username,
      'actor_display_name', actor_display
    ),
    false
  )
  on conflict (user_id, type, actor_id, entity_id) do nothing;

  return new;
end;
$function$
"
public,upsert_community_note,body text,community_notes,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.upsert_community_note(body text)
 RETURNS community_notes
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_user uuid := auth.uid();
  v_last timestamptz;
  v_note public.community_notes;
  v_remaining interval;
begin
  if v_user is null then
    raise exception 'not_authenticated';
  end if;

  if body is null or char_length(trim(body)) < 1 then
    raise exception 'empty_body';
  end if;

  if char_length(body) > 220 then
    raise exception 'body_too_long';
  end if;

  select updated_at into v_last
  from public.community_notes
  where user_id = v_user;

  if v_last is not null and now() - v_last < interval '10 minutes' then
    v_remaining := interval '10 minutes' - (now() - v_last);
    -- Put remaining seconds in ""detail"" so the client can show a countdown
    raise exception 'cooldown'
      using detail = floor(extract(epoch from v_remaining))::text;
  end if;

  insert into public.community_notes(user_id, body, created_at, updated_at)
  values (v_user, trim(body), now(), now())
  on conflict (user_id)
  do update set body = excluded.body, updated_at = now()
  returning * into v_note;

  return v_note;
end;
$function$
"
public,upsert_notification,"p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb",void,plpgsql,v,true,"CREATE OR REPLACE FUNCTION public.upsert_notification(p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_payload jsonb := p_payload;
  v_from_user_name text;
  v_from_user_avatar_url text;
BEGIN
  -- enrich payload with actor profile data (name + avatar)
  IF p_actor_id IS NOT NULL THEN
    SELECT
      COALESCE(NULLIF(pr.display_name, ''), pr.username),
      pr.avatar_url
    INTO
      v_from_user_name,
      v_from_user_avatar_url
    FROM public.profiles pr
    WHERE pr.id = p_actor_id;

    -- write/overwrite only if missing or empty (no ""duplication"", just updates the key)
    IF v_from_user_name IS NOT NULL
       AND (v_payload->>'from_user_name' IS NULL OR v_payload->>'from_user_name' = '') THEN
      v_payload := v_payload || jsonb_build_object('from_user_name', v_from_user_name);
    END IF;

    IF v_from_user_avatar_url IS NOT NULL
       AND (v_payload->>'from_user_avatar_url' IS NULL OR v_payload->>'from_user_avatar_url' = '') THEN
      v_payload := v_payload || jsonb_build_object('from_user_avatar_url', v_from_user_avatar_url);
    END IF;
  END IF;

  INSERT INTO public.notifications(user_id, actor_id, type, entity_type, entity_id, payload, is_read, created_at, read_at)
  VALUES (p_user_id, p_actor_id, p_type, p_entity_type, p_entity_id, v_payload, false, now(), null)
  ON CONFLICT (user_id, type, actor_id, entity_id)
  DO UPDATE SET
    payload    = excluded.payload,
    is_read    = false,
    created_at = now(),
    read_at    = null;
END;
$function$
"
storage,add_prefixes,"_bucket_id text, _name text",void,plpgsql,v,true,"CREATE OR REPLACE FUNCTION storage.add_prefixes(_bucket_id text, _name text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    prefixes text[];
BEGIN
    prefixes := ""storage"".""get_prefixes""(""_name"");

    IF array_length(prefixes, 1) > 0 THEN
        INSERT INTO storage.prefixes (name, bucket_id)
        SELECT UNNEST(prefixes) as name, ""_bucket_id"" ON CONFLICT DO NOTHING;
    END IF;
END;
$function$
"
storage,can_insert_object,"bucketid text, name text, owner uuid, metadata jsonb",void,plpgsql,v,false,"CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO ""storage"".""objects"" (""bucket_id"", ""name"", ""owner"", ""metadata"") VALUES (bucketid, name, owner, metadata);
  -- hack to rollback the successful insert
  RAISE sqlstate 'PT200' using
  message = 'ROLLBACK',
  detail = 'rollback successful insert';
END
$function$
"
storage,delete_leaf_prefixes,"bucket_ids text[], names text[]",void,plpgsql,v,true,"CREATE OR REPLACE FUNCTION storage.delete_leaf_prefixes(bucket_ids text[], names text[])
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_rows_deleted integer;
BEGIN
    LOOP
        WITH candidates AS (
            SELECT DISTINCT
                t.bucket_id,
                unnest(storage.get_prefixes(t.name)) AS name
            FROM unnest(bucket_ids, names) AS t(bucket_id, name)
        ),
        uniq AS (
             SELECT
                 bucket_id,
                 name,
                 storage.get_level(name) AS level
             FROM candidates
             WHERE name <> ''
             GROUP BY bucket_id, name
        ),
        leaf AS (
             SELECT
                 p.bucket_id,
                 p.name,
                 p.level
             FROM storage.prefixes AS p
                  JOIN uniq AS u
                       ON u.bucket_id = p.bucket_id
                           AND u.name = p.name
                           AND u.level = p.level
             WHERE NOT EXISTS (
                 SELECT 1
                 FROM storage.objects AS o
                 WHERE o.bucket_id = p.bucket_id
                   AND o.level = p.level + 1
                   AND o.name COLLATE ""C"" LIKE p.name || '/%'
             )
             AND NOT EXISTS (
                 SELECT 1
                 FROM storage.prefixes AS c
                 WHERE c.bucket_id = p.bucket_id
                   AND c.level = p.level + 1
                   AND c.name COLLATE ""C"" LIKE p.name || '/%'
             )
        )
        DELETE
        FROM storage.prefixes AS p
            USING leaf AS l
        WHERE p.bucket_id = l.bucket_id
          AND p.name = l.name
          AND p.level = l.level;

        GET DIAGNOSTICS v_rows_deleted = ROW_COUNT;
        EXIT WHEN v_rows_deleted = 0;
    END LOOP;
END;
$function$
"
storage,delete_prefix,"_bucket_id text, _name text",boolean,plpgsql,v,true,"CREATE OR REPLACE FUNCTION storage.delete_prefix(_bucket_id text, _name text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Check if we can delete the prefix
    IF EXISTS(
        SELECT FROM ""storage"".""prefixes""
        WHERE ""prefixes"".""bucket_id"" = ""_bucket_id""
          AND level = ""storage"".""get_level""(""_name"") + 1
          AND ""prefixes"".""name"" COLLATE ""C"" LIKE ""_name"" || '/%'
        LIMIT 1
    )
    OR EXISTS(
        SELECT FROM ""storage"".""objects""
        WHERE ""objects"".""bucket_id"" = ""_bucket_id""
          AND ""storage"".""get_level""(""objects"".""name"") = ""storage"".""get_level""(""_name"") + 1
          AND ""objects"".""name"" COLLATE ""C"" LIKE ""_name"" || '/%'
        LIMIT 1
    ) THEN
    -- There are sub-objects, skip deletion
    RETURN false;
    ELSE
        DELETE FROM ""storage"".""prefixes""
        WHERE ""prefixes"".""bucket_id"" = ""_bucket_id""
          AND level = ""storage"".""get_level""(""_name"")
          AND ""prefixes"".""name"" = ""_name"";
        RETURN true;
    END IF;
END;
$function$
"
storage,delete_prefix_hierarchy_trigger,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION storage.delete_prefix_hierarchy_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    prefix text;
BEGIN
    prefix := ""storage"".""get_prefix""(OLD.""name"");

    IF coalesce(prefix, '') != '' THEN
        PERFORM ""storage"".""delete_prefix""(OLD.""bucket_id"", prefix);
    END IF;

    RETURN OLD;
END;
$function$
"
storage,enforce_bucket_name_length,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION storage.enforce_bucket_name_length()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    if length(new.name) > 100 then
        raise exception 'bucket name ""%"" is too long (% characters). Max is 100.', new.name, length(new.name);
    end if;
    return new;
end;
$function$
"
storage,extension,name text,text,plpgsql,i,false,"CREATE OR REPLACE FUNCTION storage.extension(name text)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
    _parts text[];
    _filename text;
BEGIN
    SELECT string_to_array(name, '/') INTO _parts;
    SELECT _parts[array_length(_parts,1)] INTO _filename;
    RETURN reverse(split_part(reverse(_filename), '.', 1));
END
$function$
"
storage,filename,name text,text,plpgsql,v,false,"CREATE OR REPLACE FUNCTION storage.filename(name text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[array_length(_parts,1)];
END
$function$
"
storage,foldername,name text,text[],plpgsql,i,false,"CREATE OR REPLACE FUNCTION storage.foldername(name text)
 RETURNS text[]
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
    _parts text[];
BEGIN
    -- Split on ""/"" to get path segments
    SELECT string_to_array(name, '/') INTO _parts;
    -- Return everything except the last segment
    RETURN _parts[1 : array_length(_parts,1) - 1];
END
$function$
"
storage,get_level,name text,integer,sql,i,false,"CREATE OR REPLACE FUNCTION storage.get_level(name text)
 RETURNS integer
 LANGUAGE sql
 IMMUTABLE STRICT
AS $function$
SELECT array_length(string_to_array(""name"", '/'), 1);
$function$
"
storage,get_prefix,name text,text,sql,i,false,"CREATE OR REPLACE FUNCTION storage.get_prefix(name text)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE STRICT
AS $function$
SELECT
    CASE WHEN strpos(""name"", '/') > 0 THEN
             regexp_replace(""name"", '[\/]{1}[^\/]+\/?$', '')
         ELSE
             ''
        END;
$function$
"
storage,get_prefixes,name text,text[],plpgsql,i,false,"CREATE OR REPLACE FUNCTION storage.get_prefixes(name text)
 RETURNS text[]
 LANGUAGE plpgsql
 IMMUTABLE STRICT
AS $function$
DECLARE
    parts text[];
    prefixes text[];
    prefix text;
BEGIN
    -- Split the name into parts by '/'
    parts := string_to_array(""name"", '/');
    prefixes := '{}';

    -- Construct the prefixes, stopping one level below the last part
    FOR i IN 1..array_length(parts, 1) - 1 LOOP
            prefix := array_to_string(parts[1:i], '/');
            prefixes := array_append(prefixes, prefix);
    END LOOP;

    RETURN prefixes;
END;
$function$
"
storage,get_size_by_bucket,,"TABLE(size bigint, bucket_id text)",plpgsql,s,false,"CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()
 RETURNS TABLE(size bigint, bucket_id text)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    return query
        select sum((metadata->>'size')::bigint) as size, obj.bucket_id
        from ""storage"".objects as obj
        group by obj.bucket_id;
END
$function$
"
storage,list_multipart_uploads_with_delimiter,"bucket_id text, prefix_param text, delimiter_param text, max_keys integer, next_key_token text, next_upload_token text","TABLE(key text, id text, created_at timestamp with time zone)",plpgsql,v,false,"CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)
 RETURNS TABLE(key text, id text, created_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(key COLLATE ""C"") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))
                    ELSE
                        key
                END AS key, id, created_at
            FROM
                storage.s3_multipart_uploads
            WHERE
                bucket_id = $5 AND
                key ILIKE $1 || ''%'' AND
                CASE
                    WHEN $4 != '''' AND $6 = '''' THEN
                        CASE
                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE ""C"" > $4
                            ELSE
                                key COLLATE ""C"" > $4
                            END
                    ELSE
                        true
                END AND
                CASE
                    WHEN $6 != '''' THEN
                        id COLLATE ""C"" > $6
                    ELSE
                        true
                    END
            ORDER BY
                key COLLATE ""C"" ASC, created_at ASC) as e order by key COLLATE ""C"" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;
END;
$function$
"
storage,list_objects_with_delimiter,"bucket_id text, prefix_param text, delimiter_param text, max_keys integer, start_after text, next_token text","TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)",plpgsql,v,false,"CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)
 RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(name COLLATE ""C"") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))
                    ELSE
                        name
                END AS name, id, metadata, updated_at
            FROM
                storage.objects
            WHERE
                bucket_id = $5 AND
                name ILIKE $1 || ''%'' AND
                CASE
                    WHEN $6 != '''' THEN
                    name COLLATE ""C"" > $6
                ELSE true END
                AND CASE
                    WHEN $4 != '''' THEN
                        CASE
                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE ""C"" > $4
                            ELSE
                                name COLLATE ""C"" > $4
                            END
                    ELSE
                        true
                END
            ORDER BY
                name COLLATE ""C"" ASC) as e order by name COLLATE ""C"" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;
END;
$function$
"
storage,lock_top_prefixes,"bucket_ids text[], names text[]",void,plpgsql,v,true,"CREATE OR REPLACE FUNCTION storage.lock_top_prefixes(bucket_ids text[], names text[])
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_bucket text;
    v_top text;
BEGIN
    FOR v_bucket, v_top IN
        SELECT DISTINCT t.bucket_id,
            split_part(t.name, '/', 1) AS top
        FROM unnest(bucket_ids, names) AS t(bucket_id, name)
        WHERE t.name <> ''
        ORDER BY 1, 2
        LOOP
            PERFORM pg_advisory_xact_lock(hashtextextended(v_bucket || '/' || v_top, 0));
        END LOOP;
END;
$function$
"
storage,objects_delete_cleanup,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION storage.objects_delete_cleanup()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_bucket_ids text[];
    v_names      text[];
BEGIN
    IF current_setting('storage.gc.prefixes', true) = '1' THEN
        RETURN NULL;
    END IF;

    PERFORM set_config('storage.gc.prefixes', '1', true);

    SELECT COALESCE(array_agg(d.bucket_id), '{}'),
           COALESCE(array_agg(d.name), '{}')
    INTO v_bucket_ids, v_names
    FROM deleted AS d
    WHERE d.name <> '';

    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);
    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);

    RETURN NULL;
END;
$function$
"
storage,objects_insert_prefix_trigger,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION storage.objects_insert_prefix_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    PERFORM ""storage"".""add_prefixes""(NEW.""bucket_id"", NEW.""name"");
    NEW.level := ""storage"".""get_level""(NEW.""name"");

    RETURN NEW;
END;
$function$
"
storage,objects_update_cleanup,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION storage.objects_update_cleanup()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    -- NEW - OLD (destinations to create prefixes for)
    v_add_bucket_ids text[];
    v_add_names      text[];

    -- OLD - NEW (sources to prune)
    v_src_bucket_ids text[];
    v_src_names      text[];
BEGIN
    IF TG_OP <> 'UPDATE' THEN
        RETURN NULL;
    END IF;

    -- 1) Compute NEW−OLD (added paths) and OLD−NEW (moved-away paths)
    WITH added AS (
        SELECT n.bucket_id, n.name
        FROM new_rows n
        WHERE n.name <> '' AND position('/' in n.name) > 0
        EXCEPT
        SELECT o.bucket_id, o.name FROM old_rows o WHERE o.name <> ''
    ),
    moved AS (
         SELECT o.bucket_id, o.name
         FROM old_rows o
         WHERE o.name <> ''
         EXCEPT
         SELECT n.bucket_id, n.name FROM new_rows n WHERE n.name <> ''
    )
    SELECT
        -- arrays for ADDED (dest) in stable order
        COALESCE( (SELECT array_agg(a.bucket_id ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),
        COALESCE( (SELECT array_agg(a.name      ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),
        -- arrays for MOVED (src) in stable order
        COALESCE( (SELECT array_agg(m.bucket_id ORDER BY m.bucket_id, m.name) FROM moved m), '{}' ),
        COALESCE( (SELECT array_agg(m.name      ORDER BY m.bucket_id, m.name) FROM moved m), '{}' )
    INTO v_add_bucket_ids, v_add_names, v_src_bucket_ids, v_src_names;

    -- Nothing to do?
    IF (array_length(v_add_bucket_ids, 1) IS NULL) AND (array_length(v_src_bucket_ids, 1) IS NULL) THEN
        RETURN NULL;
    END IF;

    -- 2) Take per-(bucket, top) locks: ALL prefixes in consistent global order to prevent deadlocks
    DECLARE
        v_all_bucket_ids text[];
        v_all_names text[];
    BEGIN
        -- Combine source and destination arrays for consistent lock ordering
        v_all_bucket_ids := COALESCE(v_src_bucket_ids, '{}') || COALESCE(v_add_bucket_ids, '{}');
        v_all_names := COALESCE(v_src_names, '{}') || COALESCE(v_add_names, '{}');

        -- Single lock call ensures consistent global ordering across all transactions
        IF array_length(v_all_bucket_ids, 1) IS NOT NULL THEN
            PERFORM storage.lock_top_prefixes(v_all_bucket_ids, v_all_names);
        END IF;
    END;

    -- 3) Create destination prefixes (NEW−OLD) BEFORE pruning sources
    IF array_length(v_add_bucket_ids, 1) IS NOT NULL THEN
        WITH candidates AS (
            SELECT DISTINCT t.bucket_id, unnest(storage.get_prefixes(t.name)) AS name
            FROM unnest(v_add_bucket_ids, v_add_names) AS t(bucket_id, name)
            WHERE name <> ''
        )
        INSERT INTO storage.prefixes (bucket_id, name)
        SELECT c.bucket_id, c.name
        FROM candidates c
        ON CONFLICT DO NOTHING;
    END IF;

    -- 4) Prune source prefixes bottom-up for OLD−NEW
    IF array_length(v_src_bucket_ids, 1) IS NOT NULL THEN
        -- re-entrancy guard so DELETE on prefixes won't recurse
        IF current_setting('storage.gc.prefixes', true) <> '1' THEN
            PERFORM set_config('storage.gc.prefixes', '1', true);
        END IF;

        PERFORM storage.delete_leaf_prefixes(v_src_bucket_ids, v_src_names);
    END IF;

    RETURN NULL;
END;
$function$
"
storage,objects_update_level_trigger,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION storage.objects_update_level_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Ensure this is an update operation and the name has changed
    IF TG_OP = 'UPDATE' AND (NEW.""name"" <> OLD.""name"" OR NEW.""bucket_id"" <> OLD.""bucket_id"") THEN
        -- Set the new level
        NEW.""level"" := ""storage"".""get_level""(NEW.""name"");
    END IF;
    RETURN NEW;
END;
$function$
"
storage,objects_update_prefix_trigger,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION storage.objects_update_prefix_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    old_prefixes TEXT[];
BEGIN
    -- Ensure this is an update operation and the name has changed
    IF TG_OP = 'UPDATE' AND (NEW.""name"" <> OLD.""name"" OR NEW.""bucket_id"" <> OLD.""bucket_id"") THEN
        -- Retrieve old prefixes
        old_prefixes := ""storage"".""get_prefixes""(OLD.""name"");

        -- Remove old prefixes that are only used by this object
        WITH all_prefixes as (
            SELECT unnest(old_prefixes) as prefix
        ),
        can_delete_prefixes as (
             SELECT prefix
             FROM all_prefixes
             WHERE NOT EXISTS (
                 SELECT 1 FROM ""storage"".""objects""
                 WHERE ""bucket_id"" = OLD.""bucket_id""
                   AND ""name"" <> OLD.""name""
                   AND ""name"" LIKE (prefix || '%')
             )
         )
        DELETE FROM ""storage"".""prefixes"" WHERE name IN (SELECT prefix FROM can_delete_prefixes);

        -- Add new prefixes
        PERFORM ""storage"".""add_prefixes""(NEW.""bucket_id"", NEW.""name"");
    END IF;
    -- Set the new level
    NEW.""level"" := ""storage"".""get_level""(NEW.""name"");

    RETURN NEW;
END;
$function$
"
storage,operation,,text,plpgsql,s,false,"CREATE OR REPLACE FUNCTION storage.operation()
 RETURNS text
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    RETURN current_setting('storage.operation', true);
END;
$function$
"
storage,prefixes_delete_cleanup,,trigger,plpgsql,v,true,"CREATE OR REPLACE FUNCTION storage.prefixes_delete_cleanup()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_bucket_ids text[];
    v_names      text[];
BEGIN
    IF current_setting('storage.gc.prefixes', true) = '1' THEN
        RETURN NULL;
    END IF;

    PERFORM set_config('storage.gc.prefixes', '1', true);

    SELECT COALESCE(array_agg(d.bucket_id), '{}'),
           COALESCE(array_agg(d.name), '{}')
    INTO v_bucket_ids, v_names
    FROM deleted AS d
    WHERE d.name <> '';

    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);
    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);

    RETURN NULL;
END;
$function$
"
storage,prefixes_insert_trigger,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION storage.prefixes_insert_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    PERFORM ""storage"".""add_prefixes""(NEW.""bucket_id"", NEW.""name"");
    RETURN NEW;
END;
$function$
"
storage,search,"prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text","TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",plpgsql,v,false,"CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)
 RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
 LANGUAGE plpgsql
AS $function$
declare
    can_bypass_rls BOOLEAN;
begin
    SELECT rolbypassrls
    INTO can_bypass_rls
    FROM pg_roles
    WHERE rolname = coalesce(nullif(current_setting('role', true), 'none'), current_user);

    IF can_bypass_rls THEN
        RETURN QUERY SELECT * FROM storage.search_v1_optimised(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);
    ELSE
        RETURN QUERY SELECT * FROM storage.search_legacy_v1(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);
    END IF;
end;
$function$
"
storage,search_legacy_v1,"prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text","TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",plpgsql,s,false,"CREATE OR REPLACE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)
 RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
 LANGUAGE plpgsql
 STABLE
AS $function$
declare
    v_order_by text;
    v_sort_order text;
begin
    case
        when sortcolumn = 'name' then
            v_order_by = 'name';
        when sortcolumn = 'updated_at' then
            v_order_by = 'updated_at';
        when sortcolumn = 'created_at' then
            v_order_by = 'created_at';
        when sortcolumn = 'last_accessed_at' then
            v_order_by = 'last_accessed_at';
        else
            v_order_by = 'name';
        end case;

    case
        when sortorder = 'asc' then
            v_sort_order = 'asc';
        when sortorder = 'desc' then
            v_sort_order = 'desc';
        else
            v_sort_order = 'asc';
        end case;

    v_order_by = v_order_by || ' ' || v_sort_order;

    return query execute
        'with folders as (
           select path_tokens[$1] as folder
           from storage.objects
             where objects.name ilike $2 || $3 || ''%''
               and bucket_id = $4
               and array_length(objects.path_tokens, 1) <> $1
           group by folder
           order by folder ' || v_sort_order || '
     )
     (select folder as ""name"",
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[$1] as ""name"",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where objects.name ilike $2 || $3 || ''%''
       and bucket_id = $4
       and array_length(objects.path_tokens, 1) = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$function$
"
storage,search_v1_optimised,"prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text","TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",plpgsql,s,false,"CREATE OR REPLACE FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)
 RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
 LANGUAGE plpgsql
 STABLE
AS $function$
declare
    v_order_by text;
    v_sort_order text;
begin
    case
        when sortcolumn = 'name' then
            v_order_by = 'name';
        when sortcolumn = 'updated_at' then
            v_order_by = 'updated_at';
        when sortcolumn = 'created_at' then
            v_order_by = 'created_at';
        when sortcolumn = 'last_accessed_at' then
            v_order_by = 'last_accessed_at';
        else
            v_order_by = 'name';
        end case;

    case
        when sortorder = 'asc' then
            v_sort_order = 'asc';
        when sortorder = 'desc' then
            v_sort_order = 'desc';
        else
            v_sort_order = 'asc';
        end case;

    v_order_by = v_order_by || ' ' || v_sort_order;

    return query execute
        'with folders as (
           select (string_to_array(name, ''/''))[level] as name
           from storage.prefixes
             where lower(prefixes.name) like lower($2 || $3) || ''%''
               and bucket_id = $4
               and level = $1
           order by name ' || v_sort_order || '
     )
     (select name,
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[level] as ""name"",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where lower(objects.name) like lower($2 || $3) || ''%''
       and bucket_id = $4
       and level = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$function$
"
storage,search_v2,"prefix text, bucket_name text, limits integer, levels integer, start_after text, sort_order text, sort_column text, sort_column_after text","TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",plpgsql,s,false,"CREATE OR REPLACE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text, sort_column text DEFAULT 'name'::text, sort_column_after text DEFAULT ''::text)
 RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    sort_col text;
    sort_ord text;
    cursor_op text;
    cursor_expr text;
    sort_expr text;
BEGIN
    -- Validate sort_order
    sort_ord := lower(sort_order);
    IF sort_ord NOT IN ('asc', 'desc') THEN
        sort_ord := 'asc';
    END IF;

    -- Determine cursor comparison operator
    IF sort_ord = 'asc' THEN
        cursor_op := '>';
    ELSE
        cursor_op := '<';
    END IF;
    
    sort_col := lower(sort_column);
    -- Validate sort column  
    IF sort_col IN ('updated_at', 'created_at') THEN
        cursor_expr := format(
            '($5 = '''' OR ROW(date_trunc(''milliseconds'', %I), name COLLATE ""C"") %s ROW(COALESCE(NULLIF($6, '''')::timestamptz, ''epoch''::timestamptz), $5))',
            sort_col, cursor_op
        );
        sort_expr := format(
            'COALESCE(date_trunc(''milliseconds'', %I), ''epoch''::timestamptz) %s, name COLLATE ""C"" %s',
            sort_col, sort_ord, sort_ord
        );
    ELSE
        cursor_expr := format('($5 = '''' OR name COLLATE ""C"" %s $5)', cursor_op);
        sort_expr := format('name COLLATE ""C"" %s', sort_ord);
    END IF;

    RETURN QUERY EXECUTE format(
        $sql$
        SELECT * FROM (
            (
                SELECT
                    split_part(name, '/', $4) AS key,
                    name,
                    NULL::uuid AS id,
                    updated_at,
                    created_at,
                    NULL::timestamptz AS last_accessed_at,
                    NULL::jsonb AS metadata
                FROM storage.prefixes
                WHERE name COLLATE ""C"" LIKE $1 || '%%'
                    AND bucket_id = $2
                    AND level = $4
                    AND %s
                ORDER BY %s
                LIMIT $3
            )
            UNION ALL
            (
                SELECT
                    split_part(name, '/', $4) AS key,
                    name,
                    id,
                    updated_at,
                    created_at,
                    last_accessed_at,
                    metadata
                FROM storage.objects
                WHERE name COLLATE ""C"" LIKE $1 || '%%'
                    AND bucket_id = $2
                    AND level = $4
                    AND %s
                ORDER BY %s
                LIMIT $3
            )
        ) obj
        ORDER BY %s
        LIMIT $3
        $sql$,
        cursor_expr,    -- prefixes WHERE
        sort_expr,      -- prefixes ORDER BY
        cursor_expr,    -- objects WHERE
        sort_expr,      -- objects ORDER BY
        sort_expr       -- final ORDER BY
    )
    USING prefix, bucket_name, limits, levels, start_after, sort_column_after;
END;
$function$
"
storage,update_updated_at_column,,trigger,plpgsql,v,false,"CREATE OR REPLACE FUNCTION storage.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW; 
END;
$function$
"